<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Cinematic Gesture Christmas</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Times New Roman', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* éšè—çš„è§†é¢‘å…ƒç´ ï¼Œç”¨äºMediaPipeåˆ†æ */
        #input-video { position: absolute; top: -1000px; left: -1000px; width: 1px; height: 1px; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ°canvas */
            display: flex; flex-direction: column; justify-content: space-between;
            align-items: center; padding: 20px; box-sizing: border-box;
        }

        /* å¯åŠ¨é®ç½© */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 5, 0.9); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #D4AF37; text-align: center;
        }

        h1 {
            font-size: 2rem; letter-spacing: 5px; text-transform: uppercase;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5); margin-bottom: 30px;
        }

        button {
            pointer-events: auto;
            background: transparent; border: 1px solid #D4AF37; color: #D4AF37;
            padding: 15px 40px; font-size: 1rem; letter-spacing: 2px;
            cursor: pointer; transition: all 0.5s; text-transform: uppercase;
        }
        button:hover { background: #D4AF37; color: #000; box-shadow: 0 0 30px #D4AF37; }

        /* ä¸Šä¼ æŒ‰é’®ç¾åŒ– */
        #upload-container { pointer-events: auto; margin-bottom: 30px; text-align: center;}
        #file-input { display: none; }
        .upload-btn {
            background: rgba(46, 93, 63, 0.8); border: 1px solid #D4AF37; color: #fff;
            padding: 10px 20px; border-radius: 30px; font-size: 0.9rem;
            box-shadow: 0 0 15px rgba(46, 93, 63, 0.5); backdrop-filter: blur(5px);
        }

        #status-text {
            color: rgba(255, 255, 255, 0.6); font-size: 0.8rem; margin-top: 10px;
            text-shadow: 0 0 5px red;
        }
        
        .loading { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>

    <div id="start-overlay">
        <h1>Golden Xmas</h1>
        <p style="color: #2E5D3F; margin-bottom: 20px;">Gesture Controlled Experience</p>
        <button id="start-btn">å¼€å¯åœ£è¯é­”æ³•</button>
        <p style="font-size: 0.7rem; color: #666; margin-top: 20px;">éœ€å…è®¸æ‘„åƒå¤´æƒé™<br>ğŸ– å¼ æ‰‹æ•£å¼€ | âœŠ æ¡æ‹³èšåˆ | ğŸ‘Œ æŠ“å–ç…§ç‰‡</p>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="status-text">ç­‰å¾…æ‘„åƒå¤´...</div>
        <div id="upload-container">
            <label for="file-input" class="upload-btn">ğŸ“· ä¸Šä¼ ç…§ç‰‡ç”Ÿæˆäº‘æœµ</label>
            <input type="file" id="file-input" multiple accept="image/*">
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // ================= é…ç½®ä¸çŠ¶æ€ =================
        const COLORS = {
            MATTE_GREEN: 0x2E5D3F,
            GOLD: 0xD4AF37,
            RED: 0xB22222,
            CHERRY: 0xDC143C
        };

        const STATE = {
            TREE: 'tree',
            SCATTERED: 'scattered',
            INSPECT: 'inspect'
        };

        let currentState = STATE.TREE;
        let isTransitioning = false;
        let particles = []; // å­˜å‚¨æ‰€æœ‰3Då¯¹è±¡
        let uploadedTextures = [];
        
        // Three.js æ ¸å¿ƒå˜é‡
        let scene, camera, renderer, composer, controls;
        let raycaster, mouse;
        
        // æŠ“å–é€»è¾‘å˜é‡
        let grabbedObject = null;
        let originalScale = new THREE.Vector3();
        
        // æ‰‹åŠ¿ç›¸å…³
        let handX = 0.5, handY = 0.5; // å½’ä¸€åŒ–æ‰‹æŒåæ ‡

        // ================= åˆå§‹åŒ– Three.js =================
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 40);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // æ§åˆ¶å™¨ (ç”¨äºè°ƒè¯•æˆ–è¾…åŠ©)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = false; // ç¦ç”¨ç¼©æ”¾ï¼Œç”±æ‰‹åŠ¿æ§åˆ¶é€»è¾‘æ¥ç®¡

            // å…‰ç…§
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(COLORS.GOLD, 1.5, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            const spotLight = new THREE.SpotLight(COLORS.RED, 1);
            spotLight.position.set(-10, 20, 10);
            scene.add(spotLight);

            // åå¤„ç† (Bloom è¾‰å…‰)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = 1.2; // è¾‰å…‰å¼ºåº¦
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // å°„çº¿æ£€æµ‹
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // ç”ŸæˆåŸºç¡€æ ‘ç»“æ„
            generateTreeParticles();

            // ç›‘å¬çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
        }

        // ================= ç²’å­ç³»ç»Ÿç”Ÿæˆ =================
        function generateTreeParticles() {
            // æ¸…ç†æ—§ç²’å­
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];

            const particleCount = 250; // æ€»æ•°é‡
            const geometrySphere = new THREE.SphereGeometry(0.4, 16, 16);
            const geometryBox = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            
            // æè´¨åº“
            const matGold = new THREE.MeshStandardMaterial({ color: COLORS.GOLD, metalness: 0.9, roughness: 0.2 });
            const matGreen = new THREE.MeshStandardMaterial({ color: COLORS.MATTE_GREEN, metalness: 0.1, roughness: 0.8 });
            const matRed = new THREE.MeshStandardMaterial({ color: COLORS.RED, metalness: 0.4, roughness: 0.3, emissive: 0x330000 });
            
            // æ¨±æ¡ƒæè´¨
            const matCherry = new THREE.MeshStandardMaterial({ color: COLORS.CHERRY, metalness: 0.1, roughness: 0.1, emissive: 0x220000 });

            for (let i = 0; i < particleCount; i++) {
                let mesh;
                let type = 'decoration';
                
                // éšæœºé€‰æ‹©å½¢çŠ¶
                const rand = Math.random();
                if (rand < 0.6) {
                    // çƒä½“ (ç»¿è‰²æˆ–é‡‘è‰²)
                    mesh = new THREE.Mesh(geometrySphere, Math.random() > 0.5 ? matGreen : matGold);
                } else if (rand < 0.85) {
                    // ç›’å­ (çº¢è‰²ç¤¼ç‰©)
                    mesh = new THREE.Mesh(geometryBox, matRed);
                } else {
                    // æ¨±æ¡ƒ ğŸ’
                    mesh = new THREE.Group();
                    const c1 = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), matCherry);
                    const c2 = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), matCherry);
                    c1.position.x = -0.2;
                    c2.position.x = 0.2;
                    c2.position.y = -0.1;
                    // æ¢—
                    const stemGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.8);
                    const stemMat = new THREE.MeshBasicMaterial({color: 0x3E2723});
                    const stem1 = new THREE.Mesh(stemGeo, stemMat);
                    const stem2 = new THREE.Mesh(stemGeo, stemMat);
                    stem1.position.set(-0.2, 0.4, 0); stem1.rotation.z = -0.3;
                    stem2.position.set(0.2, 0.3, 0); stem2.rotation.z = 0.3;
                    
                    mesh.add(c1, c2, stem1, stem2);
                    type = 'cherry';
                }

                // 1. è®¡ç®—æ ‘å½¢åæ ‡ (åœ†é”¥èºæ—‹)
                const angle = i * 0.5; // èºæ—‹å¯†åº¦
                const height = 25 - (i / particleCount) * 25; // é«˜åº¦åˆ†å¸ƒ
                const radius = (25 - height) / 3; // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨çª„
                
                const treeX = Math.cos(angle) * radius + (Math.random() - 0.5);
                const treeY = height - 10;
                const treeZ = Math.sin(angle) * radius + (Math.random() - 0.5);

                // 2. è®¡ç®—æ•£å¼€åæ ‡ (çƒå½¢éšæœº)
                const sRadius = 20 + Math.random() * 15;
                const sTheta = Math.random() * Math.PI * 2;
                const sPhi = Math.acos((Math.random() * 2) - 1);
                
                const scatterX = sRadius * Math.sin(sPhi) * Math.cos(sTheta);
                const scatterY = sRadius * Math.sin(sPhi) * Math.sin(sTheta);
                const scatterZ = sRadius * Math.cos(sPhi);

                // åˆå§‹åŒ–ä½ç½®
                mesh.position.set(treeX, treeY, treeZ);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);

                scene.add(mesh);

                particles.push({
                    mesh: mesh,
                    treePos: new THREE.Vector3(treeX, treeY, treeZ),
                    scatterPos: new THREE.Vector3(scatterX, scatterY, scatterZ),
                    type: type,
                    originalScale: mesh.scale.clone()
                });
            }
        }

        // æ·»åŠ ç…§ç‰‡
        function addPhotoParticles(texture) {
            const matPhoto = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const geoPhoto = new THREE.PlaneGeometry(3, 3 * (texture.image.height/texture.image.width)); // ä¿æŒæ¯”ä¾‹

            const mesh = new THREE.Mesh(geoPhoto, matPhoto);
            
            // åˆå§‹åœ¨æ ‘çš„ä½ç½® (éšæœºæ’åœ¨æ ‘ä¸Š)
            const height = Math.random() * 20 - 8;
            const radius = (25 - (height + 10)) / 3.5;
            const angle = Math.random() * Math.PI * 2;

            const treeX = Math.cos(angle) * radius;
            const treeY = height;
            const treeZ = Math.sin(angle) * radius;

            mesh.position.set(treeX, treeY, treeZ);
            mesh.lookAt(0, treeY, 0); // é¢å‘å¤–

            // æ•£å¼€ä½ç½®
            const sRadius = 15 + Math.random() * 10;
            const scatterX = (Math.random() - 0.5) * sRadius * 2;
            const scatterY = (Math.random() - 0.5) * sRadius * 2;
            const scatterZ = (Math.random() - 0.5) * sRadius * 2;

            scene.add(mesh);
            particles.push({
                mesh: mesh,
                treePos: new THREE.Vector3(treeX, treeY, treeZ),
                scatterPos: new THREE.Vector3(scatterX, scatterY, scatterZ),
                type: 'photo',
                originalScale: mesh.scale.clone()
            });
            
            // å¦‚æœå½“å‰æ˜¯æ•£å¼€æ€ï¼Œç«‹å³é£è¿‡å»
            if(currentState === STATE.SCATTERED) {
                 new TWEEN.Tween(mesh.position)
                    .to({ x: scatterX, y: scatterY, z: scatterZ }, 1000)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .start();
            }
        }

        // ================= çŠ¶æ€åˆ‡æ¢é€»è¾‘ =================
        function switchState(newState) {
            if (newState === currentState || isTransitioning) return;
            // åªæœ‰æ•£å¼€å’Œæ ‘çŠ¶æ€ä¹‹é—´äº’æ–¥ï¼ŒInspectæ˜¯å­çŠ¶æ€
            if (currentState === STATE.INSPECT && newState === STATE.SCATTERED) {
                 releasePhoto(); // æ¾å¼€ç…§ç‰‡å›åˆ°æ•£å¼€
                 currentState = newState;
                 return;
            }

            console.log(`Switching to: ${newState}`);
            document.getElementById('status-text').innerText = `å½“å‰çŠ¶æ€: ${newState === STATE.TREE ? 'åœ£è¯æ ‘ (åˆæ‹¢)' : 'æ˜Ÿç©º (æ•£å¼€)'}`;
            
            isTransitioning = true;
            currentState = newState;

            particles.forEach(p => {
                const target = (newState === STATE.TREE) ? p.treePos : p.scatterPos;
                const duration = 1000 + Math.random() * 1000;

                // ä½ç½®åŠ¨ç”»
                new TWEEN.Tween(p.mesh.position)
                    .to({ x: target.x, y: target.y, z: target.z }, duration)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .start();

                // æ—‹è½¬åŠ¨ç”» (è®©å®ƒåŠ¨èµ·æ¥æ›´è‡ªç„¶)
                new TWEEN.Tween(p.mesh.rotation)
                    .to({ 
                        x: Math.random() * Math.PI * 2, 
                        y: Math.random() * Math.PI * 2 
                    }, duration)
                    .start();
            });

            // ç›¸æœºå½’ä½
            if (newState === STATE.TREE) {
                new TWEEN.Tween(camera.position)
                    .to({ x: 0, y: 0, z: 40 }, 1500)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }

            setTimeout(() => { isTransitioning = false; }, 2000);
        }

        // æ—‹è½¬åœºæ™¯ (ä»…åœ¨æ•£å¼€æ¨¡å¼ä¸‹)
        function rotateSceneByHand(hx, hy) {
            if (currentState !== STATE.SCATTERED) return;
            // hx, hy æ˜¯ 0-1
            const targetX = (hx - 0.5) * 100; // å·¦å³å¹…åº¦
            const targetY = (hy - 0.5) * 50;  // ä¸Šä¸‹å¹…åº¦
            
            // ç®€å•çš„ lerp
            camera.position.x += (targetX - camera.position.x) * 0.05;
            camera.position.y += (targetY - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);
        }

        // æŠ“å–ç…§ç‰‡
        function tryGrabPhoto(hx, hy) {
            if (currentState !== STATE.SCATTERED || grabbedObject) return;

            // å°†æ‰‹éƒ¨åæ ‡ (0-1) è½¬æ¢ä¸ºå±å¹•åæ ‡ (-1 åˆ° 1)
            // MediaPipe: x=0(å·¦) 1(å³), y=0(ä¸Š) 1(ä¸‹)
            // Three.js: x=-1(å·¦) 1(å³), y=1(ä¸Š) -1(ä¸‹)
            mouse.x = (1 - hx) * 2 - 1; // é•œåƒç¿»è½¬
            mouse.y = -(hy * 2 - 1);

            raycaster.setFromCamera(mouse, camera);

            // ç­›é€‰å‡ºç…§ç‰‡ç±»å‹çš„Mesh
            const photoMeshes = particles.filter(p => p.type === 'photo').map(p => p.mesh);
            if (photoMeshes.length === 0) return;

            const intersects = raycaster.intersectObjects(photoMeshes);

            if (intersects.length > 0) {
                const targetMesh = intersects[0].object;
                
                currentState = STATE.INSPECT;
                grabbedObject = targetMesh;
                
                // è®°å½•åŸå§‹ç¼©æ”¾
                const pData = particles.find(p => p.mesh === targetMesh);
                originalScale.copy(pData.originalScale);

                // åŠ¨ç”»ï¼šé£åˆ°ç›¸æœºé¢å‰å¹¶æ”¾å¤§
                // è®¡ç®—ç›¸æœºå‰æ–¹ä½ç½®
                const targetPos = new THREE.Vector3(0, 0, -10).applyMatrix4(camera.matrixWorld);
                
                new TWEEN.Tween(grabbedObject.position)
                    .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 500)
                    .easing(TWEEN.Easing.Back.Out)
                    .start();

                new TWEEN.Tween(grabbedObject.rotation)
                    .to({ x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z }, 500)
                    .start();

                new TWEEN.Tween(grabbedObject.scale)
                    .to({ x: originalScale.x * 2.5, y: originalScale.y * 2.5, z: originalScale.z * 2.5 }, 500)
                    .start();
                
                document.getElementById('status-text').innerText = "æŸ¥çœ‹ç…§ç‰‡";
            }
        }

        function releasePhoto() {
            if (!grabbedObject) return;
            
            // æ‰¾å›åŸå§‹æ•£å¼€ä½ç½®
            const pData = particles.find(p => p.mesh === grabbedObject);
            if(pData) {
                new TWEEN.Tween(grabbedObject.position)
                    .to({ x: pData.scatterPos.x, y: pData.scatterPos.y, z: pData.scatterPos.z }, 800)
                    .easing(TWEEN.Easing.Elastic.Out)
                    .start();
                
                new TWEEN.Tween(grabbedObject.scale)
                    .to({ x: pData.originalScale.x, y: pData.originalScale.y, z: pData.originalScale.z }, 800)
                    .start();
            }
            grabbedObject = null;
        }

        // ================= MediaPipe æ‰‹åŠ¿è¯†åˆ« =================
        const videoElement = document.getElementById('input-video');

        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                return;
            }

            const landmarks = results.multiHandLandmarks[0];
            
            // 1. è·å–æŒå¿ƒä½ç½® (ç”¨äºæ—‹è½¬ç›¸æœº)
            // 0 æ˜¯æ‰‹è…•, 9 æ˜¯ä¸­æŒ‡æ ¹éƒ¨. å–ä¸­é—´åšè¿‘ä¼¼æŒå¿ƒ
            handX = (landmarks[0].x + landmarks[9].x) / 2;
            handY = (landmarks[0].y + landmarks[9].y) / 2;

            // 2. è¯†åˆ«åŠ¨ä½œ
            
            // è®¡ç®—æ‰‹æŒ‡ä¼¸å±•çŠ¶æ€
            const isThumbOpen = landmarks[4].x < landmarks[3].x; // ç®€åŒ–åˆ¤å®šï¼Œå³æ‰‹é€»è¾‘
            const isIndexOpen = landmarks[8].y < landmarks[6].y;
            const isMiddleOpen = landmarks[12].y < landmarks[10].y;
            const isRingOpen = landmarks[16].y < landmarks[14].y;
            const isPinkyOpen = landmarks[20].y < landmarks[18].y;

            const openFingers = [isIndexOpen, isMiddleOpen, isRingOpen, isPinkyOpen].filter(Boolean).length;

            // åˆ¤å®šï¼šæ¡æ‹³ (Fist) -> Tree
            if (openFingers === 0) {
                switchState(STATE.TREE);
            }
            // åˆ¤å®šï¼šäº”æŒ‡å¼ å¼€ (Open) -> Scatter
            else if (openFingers >= 4) {
                switchState(STATE.SCATTERED);
            }
            
            // çŠ¶æ€æœºè¡Œä¸º
            if (currentState === STATE.SCATTERED) {
                // æ—‹è½¬ç›¸æœº
                rotateSceneByHand(handX, handY);

                // åˆ¤å®šï¼šæåˆ (Pinch/Grab) -> æ‹‡æŒ‡æŒ‡å°–(4)ä¸é£ŸæŒ‡æŒ‡å°–(8)è·ç¦»æè¿‘
                const dx = landmarks[4].x - landmarks[8].x;
                const dy = landmarks[4].y - landmarks[8].y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < 0.05) {
                    tryGrabPhoto(handX, handY);
                }
            } else if (currentState === STATE.INSPECT) {
                // å¦‚æœæ¾å¼€æåˆï¼Œåˆ™é‡Šæ”¾ç…§ç‰‡
                const dx = landmarks[4].x - landmarks[8].x;
                const dy = landmarks[4].y - landmarks[8].y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 0.08) {
                    currentState = STATE.SCATTERED; // é€»è¾‘åˆ‡å›
                    releasePhoto();
                }
            }
        }

        async function initMediaPipe() {
            const hands = new Hands({locateFile: (file) => {
                // å…³é”®ï¼šå¼ºåˆ¶ä½¿ç”¨ jsdelivr CDN é¿å… mediapipe.dev è¢«å¢™
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });

            cameraUtils.start();
        }

        // ================= è¾…åŠ©å‡½æ•° =================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            
            // ç²’å­è‡ªèº«ç¼“æ…¢æ—‹è½¬
            particles.forEach(p => {
                if(!isTransitioning) {
                    p.mesh.rotation.y += 0.005;
                    p.mesh.rotation.x += 0.002;
                }
            });

            composer.render();
        }

        // ================= äº‹ä»¶ç»‘å®š =================
        document.getElementById('start-btn').addEventListener('click', async () => {
            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('status-text').classList.add('loading');
            
            initThree();
            await initMediaPipe();
            animate();
        });

        document.getElementById('file-input').addEventListener('change', function(e) {
            const files = e.target.files;
            if(files.length > 0) {
                for(let i=0; i<files.length; i++) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const texture = new THREE.Texture(img);
                            texture.needsUpdate = true;
                            addPhotoParticles(texture);
                        }
                    };
                    reader.readAsDataURL(files[i]);
                }
                alert(`å·²æ·»åŠ  ${files.length} å¼ ç…§ç‰‡åˆ°åœ£è¯æ ‘ä¸­ï¼`);
            }
        });

    </script>
</body>
</html>